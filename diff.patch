diff --git a/.gitignore b/.gitignore
index 34f1916..1b434ef 100644
--- a/.gitignore
+++ b/.gitignore
@@ -123,4 +123,5 @@ history_issues_avoidance_files/
 
 # Local experiment script
 test_settings.py
+debug_unstructured.py
 
diff --git a/backend.py b/backend.py
index 46c7b60..804f7e4 100644
--- a/backend.py
+++ b/backend.py
@@ -18,10 +18,20 @@ from pydantic import BaseModel, Field
 
 from config import CONFIG
 from tabs.enterprise_standard.background import run_enterprise_standard_job
-from tabs.file_completeness import run_file_completeness_job
+from tabs.file_completeness import (
+    run_file_completeness_job,
+    STAGE_ORDER,
+    STAGE_SLUG_MAP,
+)
 from tabs.parameters.background import run_parameters_job
 from tabs.history.background import run_history_job
 from tabs.special_symbols.background import run_special_symbols_job
+from tabs.shared.file_conversion import (
+    process_excel_folder,
+    process_pdf_folder,
+    process_textlike_folder,
+    process_word_ppt_folder,
+)
 
 
 JOB_DEFINITIONS = {
@@ -86,6 +96,16 @@ class SpecialSymbolsJobRequest(BaseModel):
     turbo_mode: bool = False
 
 
+class ApqpParseRequest(BaseModel):
+    session_id: str
+    stages: Optional[List[str]] = None
+
+
+class ApqpClearRequest(BaseModel):
+    session_id: str
+    target: Optional[str] = "all"
+
+
 class EnterpriseJobStatus(BaseModel):
     job_id: str
     session_id: str
@@ -514,6 +534,99 @@ def ensure_session_dirs(session_id: str):
     for dir_path in dirs.values():
         os.makedirs(dir_path, exist_ok=True)
 
+
+def _apqp_stage_layout(session_id: str) -> Dict[str, Dict[str, str]]:
+    """Return upload and parsed directories for each APQP stage for a session."""
+
+    uploads_root = str(CONFIG["directories"]["uploads"])
+    generated_root = str(CONFIG["directories"]["generated_files"])
+    stage_layout: Dict[str, Dict[str, str]] = {}
+    for stage_name in STAGE_ORDER:
+        slug = STAGE_SLUG_MAP.get(stage_name, stage_name)
+        upload_dir = os.path.join(uploads_root, session_id, "APQP_one_click_check", slug)
+        parsed_dir = os.path.join(generated_root, session_id, "APQP_one_click_check", slug)
+        os.makedirs(upload_dir, exist_ok=True)
+        os.makedirs(parsed_dir, exist_ok=True)
+        stage_layout[stage_name] = {
+            "slug": slug,
+            "upload_dir": upload_dir,
+            "parsed_dir": parsed_dir,
+        }
+    return stage_layout
+
+
+def _normalize_apqp_stages(
+    layout: Dict[str, Dict[str, str]], requested: Optional[List[str]]
+) -> List[str]:
+    """Normalize requested stage identifiers to canonical stage names."""
+
+    if not requested:
+        return list(layout.keys())
+
+    name_map = {name.lower(): name for name in layout}
+    slug_map = {info["slug"].lower(): name for name, info in layout.items()}
+    result: List[str] = []
+    for item in requested:
+        token = str(item or "").strip().lower()
+        if not token:
+            continue
+        stage_name = name_map.get(token) or slug_map.get(token)
+        if not stage_name:
+            raise HTTPException(status_code=400, detail=f"æœªçŸ¥é˜¶æ®µ: {item}")
+        if stage_name not in result:
+            result.append(stage_name)
+    if not result:
+        raise HTTPException(status_code=400, detail="æœªæä¾›æœ‰æ•ˆçš„é˜¶æ®µåç§°")
+    return result
+
+
+def _clear_directory_contents(path: str) -> int:
+    """Remove all files/directories inside `path`, returning number of items removed."""
+
+    if not path:
+        return 0
+    removed = 0
+    if not os.path.isdir(path):
+        os.makedirs(path, exist_ok=True)
+        return removed
+    for name in os.listdir(path):
+        item_path = os.path.join(path, name)
+        try:
+            if os.path.isdir(item_path):
+                shutil.rmtree(item_path)
+            else:
+                os.remove(item_path)
+            removed += 1
+        except Exception:
+            continue
+    return removed
+
+
+class _ParseLogger:
+    """Collect progress messages from parsing helpers."""
+
+    def __init__(self) -> None:
+        self.messages: List[Dict[str, str]] = []
+
+    def _add(self, level: str, message: str) -> None:
+        self.messages.append({"level": level, "text": str(message)})
+
+    def write(self, message: str) -> None:
+        self._add("info", message)
+
+    def info(self, message: str) -> None:
+        self._add("info", message)
+
+    def warning(self, message: str) -> None:
+        self._add("warning", message)
+
+    def error(self, message: str) -> None:
+        self._add("error", message)
+
+    def success(self, message: str) -> None:
+        self._add("success", message)
+
+
 @app.get("/")
 async def root():
     return {"message": "PQM AI Backend is running"}
@@ -623,6 +736,119 @@ async def clear_files(request: ClearFilesRequest):
     except Exception as e:
         raise HTTPException(status_code=500, detail=f"Clear files failed: {str(e)}")
 
+
+@app.post("/apqp-one-click/parse")
+async def apqp_parse(request: ApqpParseRequest):
+    """Parse APQP uploads into text using MinerU/Unstructured pipeline."""
+
+    layout = _apqp_stage_layout(request.session_id)
+    stages = _normalize_apqp_stages(layout, request.stages)
+    summary: Dict[str, Any] = {
+        "stage_order": stages,
+        "stages": {},
+        "total_created": 0,
+    }
+
+    for stage_name in stages:
+        info = layout[stage_name]
+        upload_dir = info["upload_dir"]
+        parsed_dir = info["parsed_dir"]
+        logger = _ParseLogger()
+        stage_report: Dict[str, Any] = {
+            "slug": info["slug"],
+            "upload_dir": upload_dir,
+            "parsed_dir": parsed_dir,
+            "files_found": 0,
+            "pdf_created": 0,
+            "word_ppt_created": 0,
+            "excel_created": 0,
+            "text_created": 0,
+            "total_created": 0,
+        }
+
+        try:
+            files_found = [
+                name
+                for name in os.listdir(upload_dir)
+                if os.path.isfile(os.path.join(upload_dir, name)) and name != ".gitkeep"
+            ]
+            stage_report["files_found"] = len(files_found)
+            if not files_found:
+                logger.info("å½“å‰é˜¶æ®µæ²¡æœ‰ä¸Šä¼ æ–‡ä»¶ï¼Œè·³è¿‡è§£æã€‚")
+            else:
+                pdf_created = process_pdf_folder(
+                    upload_dir, parsed_dir, logger, annotate_sources=True
+                )
+                stage_report["pdf_created"] = len(pdf_created)
+
+                office_created = process_word_ppt_folder(
+                    upload_dir, parsed_dir, logger, annotate_sources=True
+                )
+                stage_report["word_ppt_created"] = len(office_created)
+
+                excel_created = process_excel_folder(
+                    upload_dir, parsed_dir, logger, annotate_sources=True
+                )
+                stage_report["excel_created"] = len(excel_created)
+
+                text_created = process_textlike_folder(upload_dir, parsed_dir, logger)
+                stage_report["text_created"] = len(text_created)
+
+                total_created = (
+                    len(pdf_created)
+                    + len(office_created)
+                    + len(excel_created)
+                    + len(text_created)
+                )
+                stage_report["total_created"] = total_created
+                summary["total_created"] += total_created
+        except Exception as error:
+            logger.error(f"è§£æé˜¶æ®µå¤±è´¥: {error}")
+            stage_report["error"] = str(error)
+
+        stage_report["messages"] = logger.messages
+        summary["stages"][stage_name] = stage_report
+
+    return {
+        "status": "success",
+        "summary": summary,
+    }
+
+
+@app.post("/apqp-one-click/clear")
+async def apqp_clear(request: ApqpClearRequest):
+    """Clear APQP uploads and/or parsed outputs for a session."""
+
+    layout = _apqp_stage_layout(request.session_id)
+    target = (request.target or "all").lower()
+    if target not in {"uploads", "parsed", "all"}:
+        raise HTTPException(status_code=400, detail="target å¿…é¡»æ˜¯ uploadsã€parsed æˆ– all")
+
+    details: Dict[str, Dict[str, int]] = {}
+    total_deleted = 0
+    for stage_name, info in layout.items():
+        uploads_deleted = 0
+        parsed_deleted = 0
+        if target in {"uploads", "all"}:
+            uploads_deleted = _clear_directory_contents(info["upload_dir"])
+            total_deleted += uploads_deleted
+        if target in {"parsed", "all"}:
+            parsed_deleted = _clear_directory_contents(info["parsed_dir"])
+            total_deleted += parsed_deleted
+        details[stage_name] = {
+            "uploads_deleted": uploads_deleted,
+            "parsed_deleted": parsed_deleted,
+        }
+
+    return {
+        "status": "success",
+        "target": target,
+        "deleted": total_deleted,
+        "details": details,
+        "stage_order": list(layout.keys()),
+    }
+
+
 @app.get("/file-exists/{session_id}")
 async def file_exists(session_id: str, file_path: str):
     """Check if a file exists"""
diff --git a/backend_client.py b/backend_client.py
index 90d7017..e2c2fff 100644
--- a/backend_client.py
+++ b/backend_client.py
@@ -1,6 +1,6 @@
 import requests
 import os
-from typing import Dict, List, Optional
+from typing import Any, Dict, List, Optional
 import streamlit as st
 
 class BackendClient:
@@ -55,6 +55,30 @@ class BackendClient:
         except Exception as e:
             return {"status": "error", "message": str(e)}
     
+    def parse_apqp_files(self, session_id: str, stages: Optional[List[str]] = None) -> Dict:
+        """Request backend to parse APQP uploads into text."""
+        try:
+            payload: Dict[str, Any] = {"session_id": session_id}
+            if stages:
+                payload["stages"] = stages
+            response = requests.post(
+                f"{self.base_url}/apqp-one-click/parse",
+                json=payload,
+                timeout=600,
+            )
+            return response.json()
+        except Exception as e:
+            return {"status": "error", "message": str(e)}
+    
+    def clear_apqp_files(self, session_id: str, target: str = "all") -> Dict:
+        """Clear APQP uploads and/or parsed outputs via the backend."""
+        try:
+            payload = {"session_id": session_id, "target": target}
+            response = requests.post(f"{self.base_url}/apqp-one-click/clear", json=payload, timeout=120)
+            return response.json()
+        except Exception as e:
+            return {"status": "error", "message": str(e)}
+    
     def file_exists(self, session_id: str, file_path: str) -> Dict:
         """Check if a file exists via the backend"""
         try:
diff --git a/main.py b/main.py
index 2fab892..c4b2858 100644
--- a/main.py
+++ b/main.py
@@ -10,6 +10,7 @@ from tabs.tab_ai_agent import render_ai_agent_tab
 from tabs.tab_help_documentation import render_help_documentation_tab
 from tabs.tab_home import render_home_tab
 from tabs.tab_admin import render_admin_tab
+from tabs.tab_apqp_one_click_check import render_apqp_one_click_check_tab
 from util import render_login_widget, get_user_session_id
 from util import is_admin
 
@@ -25,6 +26,7 @@ if username:
     
     # Labels and conditional admin tab
     HOME = "ğŸ  é¦–é¡µ"
+    APQP_ONE_CLICK = "âš¡ APQPäº¤ä»˜ç‰©ä¸€é”®æ£€æŸ¥"
     SPECIAL = "ğŸ” ç‰¹æ®Šç‰¹æ€§ç¬¦å·æ£€æŸ¥"
     PARAMETERS = "ğŸ“Š è®¾è®¡åˆ¶ç¨‹æ£€æŸ¥"
     ELEMENTS = "âœ… æ–‡ä»¶è¦ç´ æ£€æŸ¥"
@@ -37,7 +39,7 @@ if username:
     ADMIN = "ğŸ›¡ï¸ ç½‘ç«™ç®¡ç†"
 
     # Hide Settings for non-admin users; show both Admin and Settings for admin users
-    tab_labels = [HOME, COMPLETE, SPECIAL, PARAMETERS, ELEMENTS, ENTERPRISE, HISTORY, AI, SETTINGS, HELP]
+    tab_labels = [HOME, APQP_ONE_CLICK, COMPLETE, SPECIAL, PARAMETERS, ELEMENTS, ENTERPRISE, HISTORY, AI, SETTINGS, HELP]
     if is_admin(username):
         insert_pos = tab_labels.index(SETTINGS)
         tab_labels.insert(insert_pos, ADMIN)
@@ -47,6 +49,8 @@ if username:
 
     with tabs[idx[HOME]]:
         render_home_tab(session_id)
+    with tabs[idx[APQP_ONE_CLICK]]:
+        render_apqp_one_click_check_tab(session_id)
     with tabs[idx[COMPLETE]]:
         render_file_completeness_check_tab(session_id)
     with tabs[idx[SPECIAL]]:
